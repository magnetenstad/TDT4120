
# Pensumhefte, 2021, realisert.

## Læringsmål

### Overordnede læringsmål
De overordnede læringsmålene for emnet er som følger.

**Dere skal ha kunnskap om:**
- [ ] [X1] Et bredt spekter av etablerte algoritmer og datastrukturer
- [ ] [X2] Klassiske algoritmiske problemer med kjente effektive løsninger
- [ ] [X3] Komplekse problemer uten kjente effektive løsninger

**Dere skal kunne:**
- [ ] [X4] Analysere algoritmers korrekthet og effektivitet
- [ ] [X5] Formulere problemer så de kan løses av algoritmer
- [ ] ! [X6] Konstruere nye effektive algoritmer

**Dere skal være i stand til:**
- [ ] [X7] Å bruke eksisterende algoritmer og programvare på nye problemer
- [ ] [X8] Å utvikle nye løsninger på praktiske algoritmiske problemstillinger

### Gjennom semesteret

**Læringsmål for hver algoritme:**
- [ ] [Z1] Kjenne den formelle definisjonen av det generelle problemet den løser
- [ ] [Z2] Kjenne til eventuelle tilleggskrav den stiller for å være korrekt
- [ ] [Z3] Vite hvordan den oppfører seg; kunne utføre algoritmen, trinn for trinn
- [ ] ! [Z4] Forstå korrekthetsbeviset; hvordan og hvorfor virker algoritmen egentlig?
- [ ] [Z5] Kjenne til eventuelle styrker eller svakheter, sammenlignet med andre
- [ ] [Z6] Kjenne kjøretidene under ulike omstendigheter, og forstå utregningen

**Læringsmål for hver datastruktur:**
- [ ] [Z7] Forstå algoritmene (jf. mål Z01–Z06) for de ulike operasjonene på strukturen
- [ ] [Z8] Forstå hvordan strukturen representeres i minnet

**Læringsmål for hvert problem:**
- [ ] [Z9] Kunne angi presist hva input er
- [ ] [Z10] Kunne angi presist hva output er og hvilke egenskaper det må ha

### Forelesning 1: Problemer og algoritmer
- [ ] [A1] [Forstå bokas pseudokode-konvensjoner](#a1-forstå-bokas-pseudokode-konvensjoner)
- [ ] [A2] [Kjenne egenskapene til random-access machine-modellen (RAM)](#a2-kjenne-egenskapene-til-random-access-machine-modellen-ram)
- [ ] [A3] [Kunne definere problem, instans og problemstørrelse](#a3-kunne-definere-problem-instans-og-problemstørrelse)
- [ ] ! [A4] [Kunne definere asymptotisk notasjon, O, Ω, Θ, o og ω](#-a4-kunne-definere-asymptotisk-notasjon-o-ω-θ-o-og-ω)
- [ ] ! [A5] [Kunne definere best-case, average-case og worst-case](#-a5-kunne-definere-best-case-average-case-og-worst-case)
- [ ] ! [A6] [Forstå løkkeinvarianter og induksjon](#-a6-forstå-løkkeinvarianter-og-induksjon)
- [ ] ! [A7] [Forstå rekursiv dekomponering og induksjon over delinstanser](#-a7-forstå-rekursiv-dekomponering-og-induksjon-over-delinstanser)
- [x] [A8] [Forstå Insertion-Sort](#a8-forstå-insertion-sort)

### Forelesning 2: Datastrukturer
- [x] [B1] [Forstå hvordan stakker og køer fungerer](#b1-forstå-hvordan-stakker-og-køer-fungerer)
- [x] [B2] [Forstå hvordan lenkede lister fungerer](#b2-forstå-hvordan-lenkede-lister-fungerer)
- [ ] [B3] [Forstå hvordan pekere og objekter kan implementeres](#b3-forstå-hvordan-pekere-og-objekter-kan-implementeres)
- [ ] ! [B4] [Forstå hvordan direkte adressering og hashtabeller fungerer](#-b4-forstå-hvordan-direkte-adressering-og-hashtabeller-fungererx)
- [x] [B5] [Forstå konfliktløsing ved kjeding (chaining)](#b5-forstå-konfliktløsing-ved-kjeding-chaining)
- [ ] [B6] [Kjenne til grunnleggende hashfunksjoner](#b6-kjenne-til-grunnleggende-hashfunksjoner)
- [ ] [B7] [Vite at man for statiske datasett kan ha worst-case O(1) for søk](#b7-vite-at-man-for-statiske-datasett-kan-ha-worst-case-o1-for-søk)
- [ ] [B8] [Kunne definere amortisert analyse](#b7-vite-at-man-for-statiske-datasett-kan-ha-worst-case-o1-for-søk)
- [x] [B9] [Forstå hvordan dynamiske tabeller fungerer](#b8-kunne-definere-amortisert-analyse)

### Forelesning 3: Splitt og hersk
- [ ] ! [C1] [Forstå designmetoden divide-and-conquer (splitt og hersk)](#-c1-forstå-designmetoden-divide-and-conquer-splitt-og-hersk)
- [x] [C2] [Forstå maximum-subarray-problemet med løsninger](#c2-forstå-maximum-subarray-problemet-med-løsninger)
- [x] [C3] [Forstå Bisect og Bisect'](#c3-forstå-bisect-og-bisect)
- [x] [C4] [Forstå Merge-Sort](#c4-forstå-merge-sort)
- [x] [C5] [Forstå Quicksortog Randomized-Quicksort](#c5-forstå-quicksort-og-randomized-quicksort)
- [ ] ! [C6] [Kunne løse rekurrenser med substitusjon, rekursjonstrær og masterteoremet](#-c6-kunne-løse-rekurrenser-med-substitusjon-rekursjonstrær-og-masterteoremet)
- [ ] ! [C7] [Kunne løse rekurrenser med iterasjonsmetoden](#-c7-kunne-løse-rekurrenser-med-iterasjonsmetoden)
- [ ] [C8] [Forstå hvordan variabelskifte fungerer](#c8-forstå-hvordan-variabelskifte-fungerer)

### Forelesning 4: Rangering i lineær tid
- [ ] ! [D1] [Forstå hvorfor sammenligningsbasert sortering har en worst-case på Ω(n lg n)](#-d1-forstå-hvorfor-sammenligningsbasert-sortering-har-en-worst-case-på-ωn-lg-n)
- [ ] [D2] [Vite hva en stabil sorteringsalgoritme er](#d2-vite-hva-en-stabil-sorteringsalgoritme-er)
- [x] [D3] [Forstå Counting-Sort, og hvorfor den er stabil](#d3-forstå-counting-sort-og-hvorfor-den-er-stabil)
- [x] ! [D4] [Forstå Radix-Sort, og hvorfor den trenger en stabil subrutine](#-d4-forstå-radix-sort-og-hvorfor-den-trenger-en-stabil-subrutine)
- [x] [D5] [Forstå Bucket-Sort](#d5-forstå-bucket-sort)
- [x] [D6] [Forstå Randomized-Select](#d6-forstå-randomized-select)
- [ ] [D7] [Kjenne til Select](#d7-kjenne-til-select)

### Forelesning 5: Rotfaste trestrukturer
- [x] ! [E1] [Forstå hvordan heaps fungerer, og hvordan de kan brukes som prioritetskøer](#-e1-forstå-hvordan-heaps-fungerer-og-hvordan-de-kan-brukes-som-prioritetskøer)
- [x] [E2] [Forstå Heapsort](#e2-forstå-heapsort)
- [ ] [E3] [Forstå hvordan rotfaste trær kan implementeres](#e3-forstå-hvordan-rotfaste-trær-kan-implementeres)
- [x] ! [E4] [Forstå hvordan binære søketrær fungerer](#-e4-forstå-hvordan-binære-søketrær-fungerer)
- [ ] [E5] [Vite at forventet høyde for et tilfeldig binært søketre er Θ(lg n)](#e5-vite-at-forventet-høyde-for-et-tilfeldig-binært-søketre-er-θlg-n)
- [ ] [E6] [Vite at det finnes søketrær med garantert høyde på Θ(lg n)](#e6-vite-at-det-finnes-søketrær-med-garantert-høyde-på-θlg-n)

### Forelesning 6: Dynamisk programmering
- [ ] ! [F1] [Forstå ideen om en delinstansgraf](#-f1-forstå-ideen-om-en-delinstansgraf)
- [ ] ! [F2] [Forstå designmetoden dynamisk programmering](#-f2-forstå-designmetoden-dynamisk-programmering)
- [ ] ! [F3] [Forstå løsning ved memoisering (top-down)](#-f3-forstå-løsning-ved-memoisering-top-down)
- [ ] [F4] [Forstå løsning ved iterasjon (bottom-up)](#f4-forstå-løsning-ved-iterasjon-bottom-up)
- [ ] [F5] [Forstå hvordan man rekonstruerer en løsning fra lagrede beslutninger](#f5-forstå-hvordan-man-rekonstruerer-en-løsning-fra-lagrede-beslutninger)
- [ ] [F6] [Forstå hva optimal delstruktur er](#f6-forstå-hva-optimal-delstruktur-er)
- [ ] [F7] [Forstå hva overlappende delinstanser er](#f7-forstå-hva-overlappende-delinstanser-er)
- [x] [F8] [Forstå eksemplene stavkutting og LCS](#f8-forstå-eksemplene-stavkutting-og-lcs)
- [x] [F9] [Forstå løsningen på det binære ryggsekkproblemet](#f9-forstå-løsningen-på-det-binære-ryggsekkproblemet-knapsack-knapsack)

### Forelesning 7: Grådige algoritmer
- [ ] ! [G1] [Forstå designmetoden grådighet](#-g1-forstå-designmetoden-grådighet)
- [ ] ! [G2] [Forstå grådighetsegenskapen (the greedy-choice property)](#-g2-forstå-grådighetsegenskapen-the-greedy-choice-property)
- [ ] [G3] [Forstå eksemplene aktivitet-utvelgelse og det kontinuerlige ryggsekkproblemet](#g3-forstå-eksemplene-aktivitet-utvelgelse-og-det-kontinuerlige-ryggsekkproblemet)
- [x] [G4] [Forstå Huffman og Huffman-koder](#g4-forstå-huffman-og-huffman-koder)

### Forelesning 8: Traversering av grafer
- [ ] [H1] [Forstå hvordan grafer kan implementeres](#h1-forstå-hvordan-grafer-kan-implementeres)
- [x] [H2] [Forstå BFS, også for å finne korteste vei uten vekter](#h2-forstå-bfs-også-for-å-finne-korteste-vei-uten-vekter)
- [x] [H3] [Forstå DFS, parentesteoremet og hvit-sti-teoremet](#h3-forstå-dfs-parentesteoremet-og-hvit-sti-teoremet)
- [ ] [H4] [Forstå hvordan DFS klassifiserer kanter](#h4-forstå-hvordan-dfs-klassifiserer-kanter)
- [x] [H5] [Forstå Topological-Sort](#h5-forstå-topological-sort)
- [ ] [H6] [Forstå hvordan DFS kan implementeres med en stakk](#h6-forstå-hvordan-dfs-kan-implementeres-med-en-stakk)
- [ ] [H7] [Forstå hva traverseringstrær (som bredde-først- og dybde-først-trær) er](#h7-forstå-hva-traverseringstrær-som-bredde-først--og-dybde-først-trær-er)
- [ ] ! [H8] [Forstå traversering med vilkårlig prioritetskø](#-h8-forstå-traversering-med-vilkårlig-prioritetskø)

### Forelesning 9: Minimale spenntrær
- [x] [I1] [Forstå skog-implementasjonen av disjunkte mengder](#i1-forstå-skog-implementasjonen-av-disjunkte-mengder)
- [ ] [I2] [Vite hva spenntrær og minimale spenntrær er](#i2-vite-hva-spenntrær-og-minimale-spenntrær-er)
- [x] ! [I3] [Forstå Generic-MST](#-i3-forstå-generic-mst)
- [ ] [I4] [Forstå hvorfor lette kanter er trygge kanter](#i4-forstå-hvorfor-lette-kanter-er-trygge-kanter)
- [x] [I5] [Forstå MST-Kruskal](#i5-forstå-mst-kruskal)
- [x] [I6] [Forstå MST-Prim](#i6-forstå-mst-prim)

### Forelesning 10: Korteste vei fra én til alle
- [ ] [J1] [Forstå ulike varianter av korteste-vei- eller korteste-sti-problemet](#j1-forstå-ulike-varianter-av-korteste-vei--eller-korteste-sti-problemet-single-source-single-destination-single-pair-all-pairs)
- [ ] [J2] [Forstå strukturen til korteste-vei-problemet](#j2-forstå-strukturen-til-korteste-vei-problemet)
- [ ] [J3] [Forstå at negative sykler gir mening for korteste enkle vei (simple path)](#j3-forstå-at-negative-sykler-gir-mening-for-korteste-enkle-vei-simple-path)
- [ ] [J4] [Forstå at korteste enkle vei kan løses vha. lengste enkle vei og omvendt](#j4-forstå-at-korteste-enkle-vei-kan-løses-vha-lengste-enkle-vei-og-omvendt)
- [ ] [J5] [Forstå hvordan man kan representere et korteste-vei-tre](#j5-forstå-hvordan-man-kan-representere-et-korteste-vei-tre)
- [x] ! [J6] [Forstå kant-slakking (edge relaxation) og Relax](#-j6-forstå-kant-slakking-edge-relaxation-og-relax)
- [ ] [J7] [Forstå ulike egenskaper ved korteste veier og slakking](#j7-forstå-ulike-egenskaper-ved-korteste-veier-og-slakking)
- [x] [J8] [Forstå Bellman-Ford](#j8-forstå-bellman-ford)
- [x] [J9] [Forstå Dag-Shortest-Paths](#j9-forstå-dag-shortest-paths)
- [ ] ! [J10] [Forstå kobling mellom Dag-Shortest-Paths og dynamisk programmering](#-j10-forstå-kobling-mellom-dag-shortest-paths-og-dynamisk-programmering)
- [x] [J11] [Forstå Dijkstra](#j11-forstå-dijkstra)

### Forelesning 11: Korteste vei fra alle til alle
- [ ] [K1] [Forstå forgjengerstrukturen for alle-til-alle-varianten av korteste vei-problemet](#k1-forstå-forgjengerstrukturen-for-alle-til-alle-varianten-av-korteste-vei-problemet-print-all-pairs-shortest-path)
- [x] [K2] [Forstå Floyd-Warshall](#k2-forstå-floyd-warshall)
- [x] [K3] [Forstå Transitive-Closure](#k3-forstå-transitive-closure)
- [ ] [K4] [Forstå Johnson](#k4-forstå-johnson)

### Forelesning 12: Maksimal flyt
- [ ] [L1] [Kunne definere flytnett, flyt og maks-flyt-problemet](#l1-kunne-definere-flytnett-flyt-og-maks-flyt-problemet)
- [ ] [L2] [Kunne håndtere antiparallelle kanter og flere kilder og sluk](#l2-kunne-håndtere-antiparallelle-kanter-og-flere-kilder-og-sluk)
- [ ] ! [L3] [Kunne definere restnettet til et flytnett med en gitt flyt](#-l3-kunne-definere-restnettet-til-et-flytnett-med-en-gitt-flyt)
- [ ] [L4] [Forstå hvordan man kan oppheve (cancel) flyt](#l4-forstå-hvordan-man-kan-oppheve-cancel-flyt)
- [ ] [L5] [Forstå hva en forøkende sti (augmenting path) er](#l5-forstå-hva-en-forøkende-sti-augmenting-path-er)
- [ ] [L6] [Forstå hva snitt, snitt-kapasitet og minimalt snitt er](#l6-forstå-hva-snitt-snitt-kapasitet-og-minimalt-snitt-er)
- [ ] ! [L7] [Forstå maks-flyt/min-snitt-teoremet](#-l7-forstå-maks-flytmin-snitt-teoremet)
- [x] [L8] [Forstå Ford-Fulkerson-Method og Ford-Fulkerson](#l8-forstå-ford-fulkerson-method-og-ford-fulkerson)
- [ ] [L9] [Vite at Ford-Fulkerson med BFS kalles Edmonds-Karp-algoritmen](#l9-vite-at-ford-fulkerson-med-bfs-kalles-edmonds-karp-algoritmen)
- [ ] [L10] [Forstå hvordan maks-flyt kan finne en maksimum bipartitt matching](#l10-forstå-hvordan-maks-flyt-kan-finne-en-maksimum-bipartitt-matching)
- [ ] ! [L11] [Forstå heltallsteoremet (integrality theorem)](#-l11-forstå-heltallsteoremet-integrality-theorem)

### Forelesning 13: NP-kompletthet
- [ ] [M1] [Forstå sammenhengen mellom optimerings- og beslutnings-problemer](#m1-forstå-sammenhengen-mellom-optimerings--og-beslutnings-problemer)
- [ ] [M2] [Forstå koding (encoding) av en instans](#m2-forstå-koding-encoding-av-en-instans)
- [ ] [M3] [Forstå hvorfor løsningen på det binære ryggsekkproblemet ikke er polynomisk](#m3-forstå-hvorfor-løsningen-på-det-binære-ryggsekkproblemet-ikke-er-polynomisk)
- [ ] [M4] [Forstå forskjellen på konkrete og abstrakte problemer](#m4-forstå-forskjellen-på-konkrete-og-abstrakte-problemer)
- [ ] [M5] [Forstå representasjonen av beslutningsproblemer som formelle språk](#m5-forstå-representasjonen-av-beslutningsproblemer-som-formelle-språk)
- [ ] [M6] [Forstå definisjonen av klassene P, NP og co-NP](#m6-forstå-definisjonen-av-klassene-p-np-og-co-np)
- [ ] [M7] [Forstå redusibilitets-relasjonen $\leq_p$](#m7-forstå-redusibilitets-relasjonen-leq_p)
- [ ] ! [M8] [Forstå definisjonen av NP-hardhet og NP-kompletthet](#-m8-forstå-definisjonen-av-np-hardhet-og-np-kompletthet)
- [ ] [M9] [Forstå den konvensjonelle hypotesen om forholdet mellom P, NP og NPC](#m9-forstå-den-konvensjonelle-hypotesen-om-forholdet-mellom-p-np-og-npc)
- [ ] ! [M10] [Forstå hvordan NP-kompletthet kan bevises ved én reduksjon](#-m10-forstå-hvordan-np-kompletthet-kan-bevises-ved-én-reduksjon)
- [ ] ! [M11] [Kjenne de NP-komplette problemene CIRCUIT-SAT, SAT, 3-CNF-SAT, CLIQUE, VERTEX-COVER, HAM-CYCLE, TSP og SUBSET-SUM](#-m11-kjenne-de-np-komplette-problemene-circuit-sat-sat-3-cnf-sat-clique-vertex-cover-ham-cycle-tsp-og-subset-sum)
- [ ] [M12] [Forstå at det binære ryggsekkproblemet er NP-hardt](#m12-forstå-at-det-binære-ryggsekkproblemet-er-np-hardt)
- [ ] [M13] [Forstå at lengste enkle-vei-problemet er NP-hardt](#m13-forstå-at-lengste-enkle-vei-problemet-er-np-hardt)
- [ ] [M14] [Være i stand til å konstruere enkle NP-kompletthetsbevis](#m14-være-i-stand-til-å-konstruere-enkle-np-kompletthetsbevis)

## Realisert

### Forelesning 1: Problemer og algoritmer
#### [A1] Forstå bokas pseudokode-konvensjoner
#### [A2] Kjenne egenskapene til random-access machine-modellen (RAM)
#### [A3] Kunne definere problem, instans og problemstørrelse
#### ! [A4] Kunne definere asymptotisk notasjon, O, Ω, Θ, o og ω.
#### ! [A5] Kunne definere best-case, average-case og worst-case
#### ! [A6] Forstå løkkeinvarianter og induksjon
#### ! [A7] Forstå rekursiv dekomponering og induksjon over delinstanser
#### [A8] Forstå Insertion-Sort

##### Insertion-Sort
- Time Complexity:
  - Worst case: $\Theta(n^2)$, if input is in reverse order
  - Average case: $\Theta(n^2)$
  - Best case: $\Theta(n)$, if input is already sorted
- Space Complecity: $\Theta(1)$

In place: True
Stable: True
Loop invariant: At the start of each iteration, the subarray $A[1 \dots j - 1]$ consists of the elements originally in $A[1 \dots j - 1]$, but in sorted order.
````python
def insertion_sort(A):
    for j in range(1, len(A)):
        key = A[j]
        # Insert A[j] into the sorted sequence A[0 .. j - 1]
        i = j - 1
        while i >= 0 and A[i] > key:
            A[i + 1] = A[i]
            i -= 1
        A[i + 1] = key
````
[Implementasjon av Insertion-Sort](/lib/insertion_sort.py)

### Forelesning 2: Datastrukturer
#### [B1] Forstå hvordan stakker og køer fungerer
(Stack-Empty, Push, Pop, Enqueue, Dequeue)
[stakker](lib/structures/stack.py)
[køer](lib/structures/queue.py)

#### [B2] Forstå hvordan lenkede lister fungerer
(List-Search, List-Insert, List-Delete, List-Delete', List-Search',
List-Insert')
[lenkede lister](lib/structures/linked_list.py)

#### [B3] Forstå hvordan pekere og objekter kan implementeres
#### ! [B4] Forstå hvordan direkte adressering og hashtabeller fungerer
#### [B5] Forstå konfliktløsing ved kjeding (chaining)
(Chained-Hash-Insert, Chained-Hash-Search, Chained-Hash-Delete)
[kjeding](lib/structures/hash_table_chained.py)

#### [B6] Kjenne til grunnleggende hashfunksjoner
#### [B7] Vite at man for statiske datasett kan ha worst-case O(1) for søk
#### [B8] Kunne definere amortisert analyse
#### [B9] Forstå hvordan dynamiske tabeller fungerer
(Table-Insert)
[dynamiske tabeller](lib/structures/table.py)

### Forelesning 3: Splitt og hersk
#### ! [C1] Forstå designmetoden divide-and-conquer (splitt og hersk)
#### [C2] Forstå maximum-subarray-problemet med løsninger
[maximum-subarray-problemet](lib/find_maximum_subarray.py)

#### [C3] Forstå Bisect og Bisect'
[Bisect og Bisect'](lib/bisect.py)

#### [C4] Forstå Merge-Sort
[Merge-Sort](lib/merge_sort.py)

#### [C5] Forstå Quicksort og Randomized-Quicksort
[Quicksort](lib/quicksort.py)
[Randomized-Quicksort](lib/randomized_select.py)

#### ! [C6] Kunne løse rekurrenser med substitusjon, rekursjonstrær og masterteoremet
#### ! [C7] Kunne løse rekurrenser med iterasjonsmetoden
#### [C8] Forstå hvordan variabelskifte fungerer

### Forelesning 4: Rangering i lineær tid
#### ! [D1] Forstå hvorfor sammenligningsbasert sortering har en worst-case på Ω(n lg n)
#### [D2] Vite hva en stabil sorteringsalgoritme er
#### [D3] Forstå Counting-Sort, og hvorfor den er stabil
[Counting-Sort](lib/counting_sort.py)

#### ! [D4] Forstå Radix-Sort, og hvorfor den trenger en stabil subrutine
[Radix-Sort](lib/radix_sort.py)

#### [D5] Forstå Bucket-Sort
[Bucket-Sort](lib/bucket_sort.py)

#### [D6] Forstå Randomized-Select
[Randomized-Select](lib/randomized_select.py)

#### [D7] Kjenne til Select
Merk: Det kreves ikke grundig forståelse av virkemåten til Select.

### Forelesning 5: Rotfaste trestrukturer
#### ! [E1] Forstå hvordan heaps fungerer, og hvordan de kan brukes som prioritetskøer
(Parent, Left, Right, Max-Heapify, Build-Max-Heap, Heapsort,
Max-Heap-Insert, Heap-Extract-Max, Heap-Increase-Key, Heap-Maximum. Også
tilsvarende for min-heaps, f.eks., Build-Min-Heap og Heap-Extract-Min.)
[heaps](lib/structures/binary_heap.py)

#### [E2] Forstå Heapsort
[Heapsort](lib/heapsort.py)

#### [E3] Forstå hvordan rotfaste trær kan implementeres
#### ! [E4] Forstå hvordan binære søketrær fungerer
(Inorder-Tree-Walk, Tree-Search, Iterative-Tree-Search, Tree-Minimum, Tree-Maximum, Tree-Successor, Tree-Predecessor, Tree-Insert, Transplant, Tree-Delete)
Merk: Det kreves ikke grundig forståelse av Transplant og Tree-Delete.
[binære søketrær](lib/structures/binary_tree.py)

#### [E5] Vite at forventet høyde for et tilfeldig binært søketre er Θ(lg n)
#### [E6] Vite at det finnes søketrær med garantert høyde på Θ(lg n)

### Forelesning 6: Dynamisk programmering
#### ! [F1] Forstå ideen om en delinstansgraf
#### ! [F2] Forstå designmetoden dynamisk programmering
#### ! [F3] Forstå løsning ved memoisering (top-down)
#### [F4] Forstå løsning ved iterasjon (bottom-up)
#### [F5] Forstå hvordan man rekonstruerer en løsning fra lagrede beslutninger
#### [F6] Forstå hva optimal delstruktur er
#### [F7] Forstå hva overlappende delinstanser er
#### [F8] Forstå eksemplene stavkutting og LCS
[stavkutting](lib/cut_rod.py)
[LCS](lib/longest_common_subsequence.py)

#### [F9] Forstå løsningen på det binære ryggsekkproblemet (Knapsack, Knapsack')
[det binære ryggsekkproblemet](lib/knapsack.py)

### Forelesning 7: Grådige algoritmer
#### ! [G1] Forstå designmetoden grådighet
#### ! [G2] Forstå grådighetsegenskapen (the greedy-choice property)
#### [G3] Forstå eksemplene aktivitet-utvelgelse og det kontinuerlige ryggsekkproblemet
#### [G4] Forstå Huffman og Huffman-koder
[Huffman](lib/huffman.py)

### Forelesning 8: Traversering av grafer
#### [H1] Forstå hvordan grafer kan implementeres
#### [H2] Forstå BFS, også for å finne korteste vei uten vekter
[BFS](lib/bfs.py)

#### [H3] Forstå DFS, parentesteoremet og hvit-sti-teoremet
[DFS](lib/dfs.py)

#### [H4] Forstå hvordan DFS klassifiserer kanter
#### [H5] Forstå Topological-Sort
[Topological-Sort](lib/topological_sort.py)

#### [H6] Forstå hvordan DFS kan implementeres med en stakk
#### [H7] Forstå hva traverseringstrær (som bredde-først- og dybde-først-trær) er
#### ! [H8] Forstå traversering med vilkårlig prioritetskø

### Forelesning 9: Minimale spenntrær
#### [I1] Forstå skog-implementasjonen av disjunkte mengder
(Connected-Components, Same-Component, Make-Set, Union, Link, Find-Set)
[disjunkte mengder](lib/structures/disjunct_set.py) 

#### [I2] Vite hva spenntrær og minimale spenntrær er
#### ! [I3] Forstå Generic-MST
[Generic-MST](lib/minimal_spanning_tree.py)

#### [I4] Forstå hvorfor lette kanter er trygge kanter
#### [I5] Forstå MST-Kruskal
[MST-Kruskal](lib/minimal_spanning_tree.py)

#### [I6] Forstå MST-Prim
[MST-Prim](lib/minimal_spanning_tree.py)

### Forelesning 10: Korteste vei fra én til alle
#### [J1] Forstå ulike varianter av korteste-vei- eller korteste-sti-problemet (Single-source, single-destination, single-pair, all-pairs)
#### [J2] Forstå strukturen til korteste-vei-problemet
#### [J3] Forstå at negative sykler gir mening for korteste enkle vei (simple path)
#### [J4] Forstå at korteste enkle vei kan løses vha. lengste enkle vei og omvendt
#### [J5] Forstå hvordan man kan representere et korteste-vei-tre
#### ! [J6] Forstå kant-slakking (edge relaxation) og Relax
[Relax](lib/single_source_shortest_path.py)

#### [J7] Forstå ulike egenskaper ved korteste veier og slakking
(Triangle inequality, upper-bound property, no-path property, convergence property,
path-relaxation property, predecessor-subgraph property)
#### [J8] Forstå Bellman-Ford
[Bellman-Ford](lib/single_source_shortest_path.py)

#### [J9] Forstå Dag-Shortest-Paths
[Dag-Shortest-Paths](lib/single_source_shortest_path.py)

#### ! [J10] Forstå kobling mellom Dag-Shortest-Paths og dynamisk programmering
#### [J11] Forstå Dijkstra
 [Dijkstra](lib/single_source_shortest_path.py)

### Forelesning 11: Korteste vei fra alle til alle
#### [K1] Forstå forgjengerstrukturen for alle-til-alle-varianten av korteste vei-problemet (Print-All-Pairs-Shortest-Path)
[](lib/all_pairs_shortest_paths.py)

#### [K2] Forstå Floyd-Warshall
[Floyd-Warshall](lib/all_pairs_shortest_paths.py)

#### [K3] Forstå Transitive-Closure
[Transitive-Closure](lib/transitive_closure.py)

#### [K4] Forstå Johnson
[Johnson](lib/all_pairs_shortest_paths.py)


### Forelesning 12: Maksimal flyt
#### [L1] Kunne definere flytnett, flyt og maks-flyt-problemet
#### [L2] Kunne håndtere antiparallelle kanter og flere kilder og sluk
#### ! [L3] Kunne definere restnettet til et flytnett med en gitt flyt
#### [L4] Forstå hvordan man kan oppheve (cancel) flyt
#### [L5] Forstå hva en forøkende sti (augmenting path) er
#### [L6] Forstå hva snitt, snitt-kapasitet og minimalt snitt er
#### ! [L7] Forstå maks-flyt/min-snitt-teoremet
#### [L8] Forstå Ford-Fulkerson-Method og Ford-Fulkerson
[Ford-Fulkerson](lib/ford_fulkerson.py)

#### [L9] Vite at Ford-Fulkerson med BFS kalles Edmonds-Karp-algoritmen
[Edmonds-Karp-algoritmen](lib/ford_fulkerson.py)

#### [L10] Forstå hvordan maks-flyt kan finne en maksimum bipartitt matching
#### ! [L11] Forstå heltallsteoremet (integrality theorem)

### Forelesning 13: NP-kompletthet
#### [M1] Forstå sammenhengen mellom optimerings- og beslutnings-problemer
#### [M2] Forstå koding (encoding) av en instans
#### [M3] Forstå hvorfor løsningen på det binære ryggsekkproblemet ikke er polynomisk
#### [M4] Forstå forskjellen på konkrete og abstrakte problemer
#### [M5] Forstå representasjonen av beslutningsproblemer som formelle språk
#### [M6] Forstå definisjonen av klassene P, NP og co-NP
#### [M7] Forstå redusibilitets-relasjonen $\leq_p$
#### ! [M8] Forstå definisjonen av NP-hardhet og NP-kompletthet
#### [M9] Forstå den konvensjonelle hypotesen om forholdet mellom P, NP og NPC
#### ! [M10] Forstå hvordan NP-kompletthet kan bevises ved én reduksjon
#### ! [M11] Kjenne de NP-komplette problemene CIRCUIT-SAT, SAT, 3-CNF-SAT, CLIQUE, VERTEX-COVER, HAM-CYCLE, TSP og SUBSET-SUM
#### [M12] Forstå at det binære ryggsekkproblemet er NP-hardt
#### [M13] Forstå at lengste enkle-vei-problemet er NP-hardt
#### [M14] Være i stand til å konstruere enkle NP-kompletthetsbevis